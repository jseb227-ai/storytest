import {
  require_react_dom,
  require_scheduler
} from "./chunk-6VHNWBFI.js";
import {
  require_react
} from "./chunk-A4PXEZLR.js";
import {
  require_object_assign
} from "./chunk-E7R2VKBK.js";
import {
  __commonJS
} from "./chunk-PLDDJCW6.js";

// node_modules/react-dom/cjs/react-dom-test-utils.development.js
var require_react_dom_test_utils_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-test-utils.development.js"(exports, module) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var React = require_react();
        var ReactDOM = require_react_dom();
        var Scheduler = require_scheduler();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        if (!ReactSharedInternals.hasOwnProperty("ReactCurrentDispatcher")) {
          ReactSharedInternals.ReactCurrentDispatcher = {
            current: null
          };
        }
        if (!ReactSharedInternals.hasOwnProperty("ReactCurrentBatchConfig")) {
          ReactSharedInternals.ReactCurrentBatchConfig = {
            suspense: null
          };
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
            if (!hasExistingStack) {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
            try {
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              throw new Error(message);
            } catch (x) {
            }
          }
        }
        function get(key) {
          return key._reactInternalFiber;
        }
        var FunctionComponent = 0;
        var ClassComponent = 1;
        var HostRoot = 3;
        var HostComponent = 5;
        var HostText = 6;
        var NoEffect = (
          /*              */
          0
        );
        var Placement = (
          /*             */
          2
        );
        var Hydrating = (
          /*             */
          1024
        );
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        function getNearestMountedFiber(fiber) {
          var node = fiber;
          var nearestMounted = fiber;
          if (!fiber.alternate) {
            var nextNode = node;
            do {
              node = nextNode;
              if ((node.effectTag & (Placement | Hydrating)) !== NoEffect) {
                nearestMounted = node.return;
              }
              nextNode = node.return;
            } while (nextNode);
          } else {
            while (node.return) {
              node = node.return;
            }
          }
          if (node.tag === HostRoot) {
            return nearestMounted;
          }
          return null;
        }
        function assertIsMounted(fiber) {
          if (!(getNearestMountedFiber(fiber) === fiber)) {
            {
              throw Error("Unable to find node on an unmounted component.");
            }
          }
        }
        function findCurrentFiberUsingSlowPath(fiber) {
          var alternate = fiber.alternate;
          if (!alternate) {
            var nearestMounted = getNearestMountedFiber(fiber);
            if (!(nearestMounted !== null)) {
              {
                throw Error("Unable to find node on an unmounted component.");
              }
            }
            if (nearestMounted !== fiber) {
              return null;
            }
            return fiber;
          }
          var a = fiber;
          var b = alternate;
          while (true) {
            var parentA = a.return;
            if (parentA === null) {
              break;
            }
            var parentB = parentA.alternate;
            if (parentB === null) {
              var nextParent = parentA.return;
              if (nextParent !== null) {
                a = b = nextParent;
                continue;
              }
              break;
            }
            if (parentA.child === parentB.child) {
              var child = parentA.child;
              while (child) {
                if (child === a) {
                  assertIsMounted(parentA);
                  return fiber;
                }
                if (child === b) {
                  assertIsMounted(parentA);
                  return alternate;
                }
                child = child.sibling;
              }
              {
                {
                  throw Error("Unable to find node on an unmounted component.");
                }
              }
            }
            if (a.return !== b.return) {
              a = parentA;
              b = parentB;
            } else {
              var didFindChild = false;
              var _child = parentA.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentA;
                  b = parentB;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentA;
                  a = parentB;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                _child = parentB.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentB;
                    b = parentA;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentB;
                    a = parentA;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  {
                    throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
            }
            if (!(a.alternate === b)) {
              {
                throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          if (!(a.tag === HostRoot)) {
            {
              throw Error("Unable to find node on an unmounted component.");
            }
          }
          if (a.stateNode.current === a) {
            return fiber;
          }
          return alternate;
        }
        var EVENT_POOL_SIZE = 10;
        var EventInterface = {
          type: null,
          target: null,
          // currentTarget is set when dispatching; no use in copying it here
          currentTarget: function() {
            return null;
          },
          eventPhase: null,
          bubbles: null,
          cancelable: null,
          timeStamp: function(event) {
            return event.timeStamp || Date.now();
          },
          defaultPrevented: null,
          isTrusted: null
        };
        function functionThatReturnsTrue() {
          return true;
        }
        function functionThatReturnsFalse() {
          return false;
        }
        function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
          {
            delete this.nativeEvent;
            delete this.preventDefault;
            delete this.stopPropagation;
            delete this.isDefaultPrevented;
            delete this.isPropagationStopped;
          }
          this.dispatchConfig = dispatchConfig;
          this._targetInst = targetInst;
          this.nativeEvent = nativeEvent;
          var Interface = this.constructor.Interface;
          for (var propName in Interface) {
            if (!Interface.hasOwnProperty(propName)) {
              continue;
            }
            {
              delete this[propName];
            }
            var normalize = Interface[propName];
            if (normalize) {
              this[propName] = normalize(nativeEvent);
            } else {
              if (propName === "target") {
                this.target = nativeEventTarget;
              } else {
                this[propName] = nativeEvent[propName];
              }
            }
          }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
          if (defaultPrevented) {
            this.isDefaultPrevented = functionThatReturnsTrue;
          } else {
            this.isDefaultPrevented = functionThatReturnsFalse;
          }
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        _assign(SyntheticEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.preventDefault) {
              event.preventDefault();
            } else if (typeof event.returnValue !== "unknown") {
              event.returnValue = false;
            }
            this.isDefaultPrevented = functionThatReturnsTrue;
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.stopPropagation) {
              event.stopPropagation();
            } else if (typeof event.cancelBubble !== "unknown") {
              event.cancelBubble = true;
            }
            this.isPropagationStopped = functionThatReturnsTrue;
          },
          /**
           * We release all dispatched `SyntheticEvent`s after each event loop, adding
           * them back into the pool. This allows a way to hold onto a reference that
           * won't be added back into the pool.
           */
          persist: function() {
            this.isPersistent = functionThatReturnsTrue;
          },
          /**
           * Checks if this event should be released back into the pool.
           *
           * @return {boolean} True if this should not be released, false otherwise.
           */
          isPersistent: functionThatReturnsFalse,
          /**
           * `PooledClass` looks for `destructor` on each instance it releases.
           */
          destructor: function() {
            var Interface = this.constructor.Interface;
            for (var propName in Interface) {
              {
                Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
              }
            }
            this.dispatchConfig = null;
            this._targetInst = null;
            this.nativeEvent = null;
            this.isDefaultPrevented = functionThatReturnsFalse;
            this.isPropagationStopped = functionThatReturnsFalse;
            this._dispatchListeners = null;
            this._dispatchInstances = null;
            {
              Object.defineProperty(this, "nativeEvent", getPooledWarningPropertyDefinition("nativeEvent", null));
              Object.defineProperty(this, "isDefaultPrevented", getPooledWarningPropertyDefinition("isDefaultPrevented", functionThatReturnsFalse));
              Object.defineProperty(this, "isPropagationStopped", getPooledWarningPropertyDefinition("isPropagationStopped", functionThatReturnsFalse));
              Object.defineProperty(this, "preventDefault", getPooledWarningPropertyDefinition("preventDefault", function() {
              }));
              Object.defineProperty(this, "stopPropagation", getPooledWarningPropertyDefinition("stopPropagation", function() {
              }));
            }
          }
        });
        SyntheticEvent.Interface = EventInterface;
        SyntheticEvent.extend = function(Interface) {
          var Super = this;
          var E = function() {
          };
          E.prototype = Super.prototype;
          var prototype = new E();
          function Class() {
            return Super.apply(this, arguments);
          }
          _assign(prototype, Class.prototype);
          Class.prototype = prototype;
          Class.prototype.constructor = Class;
          Class.Interface = _assign({}, Super.Interface, Interface);
          Class.extend = Super.extend;
          addEventPoolingTo(Class);
          return Class;
        };
        addEventPoolingTo(SyntheticEvent);
        function getPooledWarningPropertyDefinition(propName, getVal) {
          var isFunction = typeof getVal === "function";
          return {
            configurable: true,
            set,
            get: get2
          };
          function set(val) {
            var action = isFunction ? "setting the method" : "setting the property";
            warn2(action, "This is effectively a no-op");
            return val;
          }
          function get2() {
            var action = isFunction ? "accessing the method" : "accessing the property";
            var result = isFunction ? "This is a no-op function" : "This is set to null";
            warn2(action, result);
            return getVal;
          }
          function warn2(action, result) {
            {
              error("This synthetic event is reused for performance reasons. If you're seeing this, you're %s `%s` on a released/nullified synthetic event. %s. If you must keep the original synthetic event around, use event.persist(). See https://fb.me/react-event-pooling for more information.", action, propName, result);
            }
          }
        }
        function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
          var EventConstructor = this;
          if (EventConstructor.eventPool.length) {
            var instance = EventConstructor.eventPool.pop();
            EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
            return instance;
          }
          return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
        }
        function releasePooledEvent(event) {
          var EventConstructor = this;
          if (!(event instanceof EventConstructor)) {
            {
              throw Error("Trying to release an event instance into a pool of a different type.");
            }
          }
          event.destructor();
          if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
            EventConstructor.eventPool.push(event);
          }
        }
        function addEventPoolingTo(EventConstructor) {
          EventConstructor.eventPool = [];
          EventConstructor.getPooled = getPooledEvent;
          EventConstructor.release = releasePooledEvent;
        }
        var ELEMENT_NODE = 1;
        function unsafeCastStringToDOMTopLevelType(topLevelType) {
          return topLevelType;
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        function makePrefixMap(styleProp, eventName) {
          var prefixes = {};
          prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
          prefixes["Webkit" + styleProp] = "webkit" + eventName;
          prefixes["Moz" + styleProp] = "moz" + eventName;
          return prefixes;
        }
        var vendorPrefixes = {
          animationend: makePrefixMap("Animation", "AnimationEnd"),
          animationiteration: makePrefixMap("Animation", "AnimationIteration"),
          animationstart: makePrefixMap("Animation", "AnimationStart"),
          transitionend: makePrefixMap("Transition", "TransitionEnd")
        };
        var prefixedEventNames = {};
        var style = {};
        if (canUseDOM) {
          style = document.createElement("div").style;
          if (!("AnimationEvent" in window)) {
            delete vendorPrefixes.animationend.animation;
            delete vendorPrefixes.animationiteration.animation;
            delete vendorPrefixes.animationstart.animation;
          }
          if (!("TransitionEvent" in window)) {
            delete vendorPrefixes.transitionend.transition;
          }
        }
        function getVendorPrefixedEventName(eventName) {
          if (prefixedEventNames[eventName]) {
            return prefixedEventNames[eventName];
          } else if (!vendorPrefixes[eventName]) {
            return eventName;
          }
          var prefixMap = vendorPrefixes[eventName];
          for (var styleProp in prefixMap) {
            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
              return prefixedEventNames[eventName] = prefixMap[styleProp];
            }
          }
          return eventName;
        }
        var TOP_ABORT = unsafeCastStringToDOMTopLevelType("abort");
        var TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationend"));
        var TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationiteration"));
        var TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("animationstart"));
        var TOP_BLUR = unsafeCastStringToDOMTopLevelType("blur");
        var TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType("canplay");
        var TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType("canplaythrough");
        var TOP_CANCEL = unsafeCastStringToDOMTopLevelType("cancel");
        var TOP_CHANGE = unsafeCastStringToDOMTopLevelType("change");
        var TOP_CLICK = unsafeCastStringToDOMTopLevelType("click");
        var TOP_CLOSE = unsafeCastStringToDOMTopLevelType("close");
        var TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType("compositionend");
        var TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType("compositionstart");
        var TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType("compositionupdate");
        var TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType("contextmenu");
        var TOP_COPY = unsafeCastStringToDOMTopLevelType("copy");
        var TOP_CUT = unsafeCastStringToDOMTopLevelType("cut");
        var TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType("dblclick");
        var TOP_DRAG = unsafeCastStringToDOMTopLevelType("drag");
        var TOP_DRAG_END = unsafeCastStringToDOMTopLevelType("dragend");
        var TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType("dragenter");
        var TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType("dragexit");
        var TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType("dragleave");
        var TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType("dragover");
        var TOP_DRAG_START = unsafeCastStringToDOMTopLevelType("dragstart");
        var TOP_DROP = unsafeCastStringToDOMTopLevelType("drop");
        var TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType("durationchange");
        var TOP_EMPTIED = unsafeCastStringToDOMTopLevelType("emptied");
        var TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType("encrypted");
        var TOP_ENDED = unsafeCastStringToDOMTopLevelType("ended");
        var TOP_ERROR = unsafeCastStringToDOMTopLevelType("error");
        var TOP_FOCUS = unsafeCastStringToDOMTopLevelType("focus");
        var TOP_INPUT = unsafeCastStringToDOMTopLevelType("input");
        var TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType("keydown");
        var TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType("keypress");
        var TOP_KEY_UP = unsafeCastStringToDOMTopLevelType("keyup");
        var TOP_LOAD = unsafeCastStringToDOMTopLevelType("load");
        var TOP_LOAD_START = unsafeCastStringToDOMTopLevelType("loadstart");
        var TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType("loadeddata");
        var TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType("loadedmetadata");
        var TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType("mousedown");
        var TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType("mousemove");
        var TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType("mouseout");
        var TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType("mouseover");
        var TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType("mouseup");
        var TOP_PASTE = unsafeCastStringToDOMTopLevelType("paste");
        var TOP_PAUSE = unsafeCastStringToDOMTopLevelType("pause");
        var TOP_PLAY = unsafeCastStringToDOMTopLevelType("play");
        var TOP_PLAYING = unsafeCastStringToDOMTopLevelType("playing");
        var TOP_PROGRESS = unsafeCastStringToDOMTopLevelType("progress");
        var TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType("ratechange");
        var TOP_SCROLL = unsafeCastStringToDOMTopLevelType("scroll");
        var TOP_SEEKED = unsafeCastStringToDOMTopLevelType("seeked");
        var TOP_SEEKING = unsafeCastStringToDOMTopLevelType("seeking");
        var TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType("selectionchange");
        var TOP_STALLED = unsafeCastStringToDOMTopLevelType("stalled");
        var TOP_SUSPEND = unsafeCastStringToDOMTopLevelType("suspend");
        var TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType("textInput");
        var TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType("timeupdate");
        var TOP_TOGGLE = unsafeCastStringToDOMTopLevelType("toggle");
        var TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType("touchcancel");
        var TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType("touchend");
        var TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType("touchmove");
        var TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType("touchstart");
        var TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName("transitionend"));
        var TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType("volumechange");
        var TOP_WAITING = unsafeCastStringToDOMTopLevelType("waiting");
        var TOP_WHEEL = unsafeCastStringToDOMTopLevelType("wheel");
        var PLUGIN_EVENT_SYSTEM = 1;
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module && module[requireString];
              enqueueTaskImpl = nodeRequire("timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var _ReactDOM$__SECRET_IN = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events, getInstanceFromNode = _ReactDOM$__SECRET_IN[0], getNodeFromInstance = _ReactDOM$__SECRET_IN[1], getFiberCurrentPropsFromNode = _ReactDOM$__SECRET_IN[2], injectEventPluginsByName = _ReactDOM$__SECRET_IN[3], eventNameDispatchConfigs = _ReactDOM$__SECRET_IN[4], accumulateTwoPhaseDispatches = _ReactDOM$__SECRET_IN[5], accumulateDirectDispatches = _ReactDOM$__SECRET_IN[6], enqueueStateRestore = _ReactDOM$__SECRET_IN[7], restoreStateIfNeeded = _ReactDOM$__SECRET_IN[8], dispatchEvent = _ReactDOM$__SECRET_IN[9], runEventsInBatch = _ReactDOM$__SECRET_IN[10], flushPassiveEffects = _ReactDOM$__SECRET_IN[11], IsThisRendererActing = _ReactDOM$__SECRET_IN[12];
        var batchedUpdates = ReactDOM.unstable_batchedUpdates;
        var IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
        var isSchedulerMocked = typeof Scheduler.unstable_flushAllWithoutAsserting === "function";
        var flushWork = Scheduler.unstable_flushAllWithoutAsserting || function() {
          var didFlushWork = false;
          while (flushPassiveEffects()) {
            didFlushWork = true;
          }
          return didFlushWork;
        };
        function flushWorkAndMicroTasks(onDone) {
          try {
            flushWork();
            enqueueTask(function() {
              if (flushWork()) {
                flushWorkAndMicroTasks(onDone);
              } else {
                onDone();
              }
            });
          } catch (err) {
            onDone(err);
          }
        }
        var actingUpdatesScopeDepth = 0;
        function act(callback) {
          var previousActingUpdatesScopeDepth = actingUpdatesScopeDepth;
          var previousIsSomeRendererActing;
          var previousIsThisRendererActing;
          actingUpdatesScopeDepth++;
          previousIsSomeRendererActing = IsSomeRendererActing.current;
          previousIsThisRendererActing = IsThisRendererActing.current;
          IsSomeRendererActing.current = true;
          IsThisRendererActing.current = true;
          function onDone() {
            actingUpdatesScopeDepth--;
            IsSomeRendererActing.current = previousIsSomeRendererActing;
            IsThisRendererActing.current = previousIsThisRendererActing;
            {
              if (actingUpdatesScopeDepth > previousActingUpdatesScopeDepth) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
            }
          }
          var result;
          try {
            result = batchedUpdates(callback);
          } catch (error2) {
            onDone();
            throw error2;
          }
          if (result !== null && typeof result === "object" && typeof result.then === "function") {
            var called = false;
            {
              if (typeof Promise !== "undefined") {
                Promise.resolve().then(function() {
                }).then(function() {
                  if (called === false) {
                    error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                  }
                });
              }
            }
            return {
              then: function(resolve, reject) {
                called = true;
                result.then(function() {
                  if (actingUpdatesScopeDepth > 1 || isSchedulerMocked === true && previousIsSomeRendererActing === true) {
                    onDone();
                    resolve();
                    return;
                  }
                  flushWorkAndMicroTasks(function(err) {
                    onDone();
                    if (err) {
                      reject(err);
                    } else {
                      resolve();
                    }
                  });
                }, function(err) {
                  onDone();
                  reject(err);
                });
              }
            };
          } else {
            {
              if (result !== void 0) {
                error("The callback passed to act(...) function must return undefined, or a Promise. You returned %s", result);
              }
            }
            try {
              if (actingUpdatesScopeDepth === 1 && (isSchedulerMocked === false || previousIsSomeRendererActing === false)) {
                flushWork();
              }
              onDone();
            } catch (err) {
              onDone();
              throw err;
            }
            return {
              then: function(resolve) {
                {
                  error("Do not await the result of calling act(...) with sync logic, it is not a Promise.");
                }
                resolve();
              }
            };
          }
        }
        var findDOMNode = ReactDOM.findDOMNode;
        var _ReactDOM$__SECRET_IN$1 = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Events, getInstanceFromNode$1 = _ReactDOM$__SECRET_IN$1[0], getNodeFromInstance$1 = _ReactDOM$__SECRET_IN$1[1], getFiberCurrentPropsFromNode$1 = _ReactDOM$__SECRET_IN$1[2], injectEventPluginsByName$1 = _ReactDOM$__SECRET_IN$1[3], eventNameDispatchConfigs$1 = _ReactDOM$__SECRET_IN$1[4], accumulateTwoPhaseDispatches$1 = _ReactDOM$__SECRET_IN$1[5], accumulateDirectDispatches$1 = _ReactDOM$__SECRET_IN$1[6], enqueueStateRestore$1 = _ReactDOM$__SECRET_IN$1[7], restoreStateIfNeeded$1 = _ReactDOM$__SECRET_IN$1[8], dispatchEvent$1 = _ReactDOM$__SECRET_IN$1[9], runEventsInBatch$1 = _ReactDOM$__SECRET_IN$1[10], flushPassiveEffects$1 = _ReactDOM$__SECRET_IN$1[11], IsThisRendererActing$1 = _ReactDOM$__SECRET_IN$1[12];
        function Event(suffix) {
        }
        var hasWarnedAboutDeprecatedMockComponent = false;
        function simulateNativeEventOnNode(topLevelType, node, fakeNativeEvent) {
          fakeNativeEvent.target = node;
          dispatchEvent$1(topLevelType, PLUGIN_EVENT_SYSTEM, document, fakeNativeEvent);
        }
        function simulateNativeEventOnDOMComponent(topLevelType, comp, fakeNativeEvent) {
          simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
        }
        function findAllInRenderedFiberTreeInternal(fiber, test) {
          if (!fiber) {
            return [];
          }
          var currentParent = findCurrentFiberUsingSlowPath(fiber);
          if (!currentParent) {
            return [];
          }
          var node = currentParent;
          var ret = [];
          while (true) {
            if (node.tag === HostComponent || node.tag === HostText || node.tag === ClassComponent || node.tag === FunctionComponent) {
              var publicInst = node.stateNode;
              if (test(publicInst)) {
                ret.push(publicInst);
              }
            }
            if (node.child) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === currentParent) {
              return ret;
            }
            while (!node.sibling) {
              if (!node.return || node.return === currentParent) {
                return ret;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        function validateClassInstance(inst, methodName) {
          if (!inst) {
            return;
          }
          if (get(inst)) {
            return;
          }
          var received;
          var stringified = "" + inst;
          if (Array.isArray(inst)) {
            received = "an array";
          } else if (inst && inst.nodeType === ELEMENT_NODE && inst.tagName) {
            received = "a DOM node";
          } else if (stringified === "[object Object]") {
            received = "object with keys {" + Object.keys(inst).join(", ") + "}";
          } else {
            received = stringified;
          }
          {
            {
              throw Error(methodName + "(...): the first argument must be a React class instance. Instead received: " + received + ".");
            }
          }
        }
        var ReactTestUtils = {
          renderIntoDocument: function(element) {
            var div = document.createElement("div");
            return ReactDOM.render(element, div);
          },
          isElement: function(element) {
            return React.isValidElement(element);
          },
          isElementOfType: function(inst, convenienceConstructor) {
            return React.isValidElement(inst) && inst.type === convenienceConstructor;
          },
          isDOMComponent: function(inst) {
            return !!(inst && inst.nodeType === ELEMENT_NODE && inst.tagName);
          },
          isDOMComponentElement: function(inst) {
            return !!(inst && React.isValidElement(inst) && !!inst.tagName);
          },
          isCompositeComponent: function(inst) {
            if (ReactTestUtils.isDOMComponent(inst)) {
              return false;
            }
            return inst != null && typeof inst.render === "function" && typeof inst.setState === "function";
          },
          isCompositeComponentWithType: function(inst, type) {
            if (!ReactTestUtils.isCompositeComponent(inst)) {
              return false;
            }
            var internalInstance = get(inst);
            var constructor = internalInstance.type;
            return constructor === type;
          },
          findAllInRenderedTree: function(inst, test) {
            validateClassInstance(inst, "findAllInRenderedTree");
            if (!inst) {
              return [];
            }
            var internalInstance = get(inst);
            return findAllInRenderedFiberTreeInternal(internalInstance, test);
          },
          /**
           * Finds all instance of components in the rendered tree that are DOM
           * components with the class name matching `className`.
           * @return {array} an array of all the matches.
           */
          scryRenderedDOMComponentsWithClass: function(root, classNames) {
            validateClassInstance(root, "scryRenderedDOMComponentsWithClass");
            return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
              if (ReactTestUtils.isDOMComponent(inst)) {
                var className = inst.className;
                if (typeof className !== "string") {
                  className = inst.getAttribute("class") || "";
                }
                var classList = className.split(/\s+/);
                if (!Array.isArray(classNames)) {
                  if (!(classNames !== void 0)) {
                    {
                      throw Error("TestUtils.scryRenderedDOMComponentsWithClass expects a className as a second argument.");
                    }
                  }
                  classNames = classNames.split(/\s+/);
                }
                return classNames.every(function(name) {
                  return classList.indexOf(name) !== -1;
                });
              }
              return false;
            });
          },
          /**
           * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
           * and returns that one result, or throws exception if there is any other
           * number of matches besides one.
           * @return {!ReactDOMComponent} The one match.
           */
          findRenderedDOMComponentWithClass: function(root, className) {
            validateClassInstance(root, "findRenderedDOMComponentWithClass");
            var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
            if (all.length !== 1) {
              throw new Error("Did not find exactly one match (found: " + all.length + ") for class:" + className);
            }
            return all[0];
          },
          /**
           * Finds all instance of components in the rendered tree that are DOM
           * components with the tag name matching `tagName`.
           * @return {array} an array of all the matches.
           */
          scryRenderedDOMComponentsWithTag: function(root, tagName) {
            validateClassInstance(root, "scryRenderedDOMComponentsWithTag");
            return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
              return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
            });
          },
          /**
           * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
           * and returns that one result, or throws exception if there is any other
           * number of matches besides one.
           * @return {!ReactDOMComponent} The one match.
           */
          findRenderedDOMComponentWithTag: function(root, tagName) {
            validateClassInstance(root, "findRenderedDOMComponentWithTag");
            var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
            if (all.length !== 1) {
              throw new Error("Did not find exactly one match (found: " + all.length + ") for tag:" + tagName);
            }
            return all[0];
          },
          /**
           * Finds all instances of components with type equal to `componentType`.
           * @return {array} an array of all the matches.
           */
          scryRenderedComponentsWithType: function(root, componentType) {
            validateClassInstance(root, "scryRenderedComponentsWithType");
            return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
              return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
            });
          },
          /**
           * Same as `scryRenderedComponentsWithType` but expects there to be one result
           * and returns that one result, or throws exception if there is any other
           * number of matches besides one.
           * @return {!ReactComponent} The one match.
           */
          findRenderedComponentWithType: function(root, componentType) {
            validateClassInstance(root, "findRenderedComponentWithType");
            var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
            if (all.length !== 1) {
              throw new Error("Did not find exactly one match (found: " + all.length + ") for componentType:" + componentType);
            }
            return all[0];
          },
          /**
           * Pass a mocked component module to this method to augment it with
           * useful methods that allow it to be used as a dummy React component.
           * Instead of rendering as usual, the component will become a simple
           * <div> containing any provided children.
           *
           * @param {object} module the mock function object exported from a
           *                        module that defines the component to be mocked
           * @param {?string} mockTagName optional dummy root tag name to return
           *                              from render method (overrides
           *                              module.mockTagName if provided)
           * @return {object} the ReactTestUtils object (for chaining)
           */
          mockComponent: function(module2, mockTagName) {
            {
              if (!hasWarnedAboutDeprecatedMockComponent) {
                hasWarnedAboutDeprecatedMockComponent = true;
                warn("ReactTestUtils.mockComponent() is deprecated. Use shallow rendering or jest.mock() instead.\n\nSee https://fb.me/test-utils-mock-component for more information.");
              }
            }
            mockTagName = mockTagName || module2.mockTagName || "div";
            module2.prototype.render.mockImplementation(function() {
              return React.createElement(mockTagName, null, this.props.children);
            });
            return this;
          },
          nativeTouchData: function(x, y) {
            return {
              touches: [{
                pageX: x,
                pageY: y
              }]
            };
          },
          Simulate: null,
          SimulateNative: {},
          act
        };
        function makeSimulator(eventType) {
          return function(domNode, eventData) {
            if (!!React.isValidElement(domNode)) {
              {
                throw Error("TestUtils.Simulate expected a DOM node as the first argument but received a React element. Pass the DOM node you wish to simulate the event on instead. Note that TestUtils.Simulate will not work if you are using shallow rendering.");
              }
            }
            if (!!ReactTestUtils.isCompositeComponent(domNode)) {
              {
                throw Error("TestUtils.Simulate expected a DOM node as the first argument but received a component instance. Pass the DOM node you wish to simulate the event on instead.");
              }
            }
            var dispatchConfig = eventNameDispatchConfigs$1[eventType];
            var fakeNativeEvent = new Event();
            fakeNativeEvent.target = domNode;
            fakeNativeEvent.type = eventType.toLowerCase();
            var targetInst = getInstanceFromNode$1(domNode);
            var event = new SyntheticEvent(dispatchConfig, targetInst, fakeNativeEvent, domNode);
            event.persist();
            _assign(event, eventData);
            if (dispatchConfig.phasedRegistrationNames) {
              accumulateTwoPhaseDispatches$1(event);
            } else {
              accumulateDirectDispatches$1(event);
            }
            ReactDOM.unstable_batchedUpdates(function() {
              enqueueStateRestore$1(domNode);
              runEventsInBatch$1(event);
            });
            restoreStateIfNeeded$1();
          };
        }
        function buildSimulators() {
          ReactTestUtils.Simulate = {};
          var eventType;
          for (eventType in eventNameDispatchConfigs$1) {
            ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
          }
        }
        buildSimulators();
        function makeNativeSimulator(eventType, topLevelType) {
          return function(domComponentOrNode, nativeEventData) {
            var fakeNativeEvent = new Event(eventType);
            _assign(fakeNativeEvent, nativeEventData);
            if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
              simulateNativeEventOnDOMComponent(topLevelType, domComponentOrNode, fakeNativeEvent);
            } else if (domComponentOrNode.tagName) {
              simulateNativeEventOnNode(topLevelType, domComponentOrNode, fakeNativeEvent);
            }
          };
        }
        [[TOP_ABORT, "abort"], [TOP_ANIMATION_END, "animationEnd"], [TOP_ANIMATION_ITERATION, "animationIteration"], [TOP_ANIMATION_START, "animationStart"], [TOP_BLUR, "blur"], [TOP_CAN_PLAY_THROUGH, "canPlayThrough"], [TOP_CAN_PLAY, "canPlay"], [TOP_CANCEL, "cancel"], [TOP_CHANGE, "change"], [TOP_CLICK, "click"], [TOP_CLOSE, "close"], [TOP_COMPOSITION_END, "compositionEnd"], [TOP_COMPOSITION_START, "compositionStart"], [TOP_COMPOSITION_UPDATE, "compositionUpdate"], [TOP_CONTEXT_MENU, "contextMenu"], [TOP_COPY, "copy"], [TOP_CUT, "cut"], [TOP_DOUBLE_CLICK, "doubleClick"], [TOP_DRAG_END, "dragEnd"], [TOP_DRAG_ENTER, "dragEnter"], [TOP_DRAG_EXIT, "dragExit"], [TOP_DRAG_LEAVE, "dragLeave"], [TOP_DRAG_OVER, "dragOver"], [TOP_DRAG_START, "dragStart"], [TOP_DRAG, "drag"], [TOP_DROP, "drop"], [TOP_DURATION_CHANGE, "durationChange"], [TOP_EMPTIED, "emptied"], [TOP_ENCRYPTED, "encrypted"], [TOP_ENDED, "ended"], [TOP_ERROR, "error"], [TOP_FOCUS, "focus"], [TOP_INPUT, "input"], [TOP_KEY_DOWN, "keyDown"], [TOP_KEY_PRESS, "keyPress"], [TOP_KEY_UP, "keyUp"], [TOP_LOAD_START, "loadStart"], [TOP_LOAD_START, "loadStart"], [TOP_LOAD, "load"], [TOP_LOADED_DATA, "loadedData"], [TOP_LOADED_METADATA, "loadedMetadata"], [TOP_MOUSE_DOWN, "mouseDown"], [TOP_MOUSE_MOVE, "mouseMove"], [TOP_MOUSE_OUT, "mouseOut"], [TOP_MOUSE_OVER, "mouseOver"], [TOP_MOUSE_UP, "mouseUp"], [TOP_PASTE, "paste"], [TOP_PAUSE, "pause"], [TOP_PLAY, "play"], [TOP_PLAYING, "playing"], [TOP_PROGRESS, "progress"], [TOP_RATE_CHANGE, "rateChange"], [TOP_SCROLL, "scroll"], [TOP_SEEKED, "seeked"], [TOP_SEEKING, "seeking"], [TOP_SELECTION_CHANGE, "selectionChange"], [TOP_STALLED, "stalled"], [TOP_SUSPEND, "suspend"], [TOP_TEXT_INPUT, "textInput"], [TOP_TIME_UPDATE, "timeUpdate"], [TOP_TOGGLE, "toggle"], [TOP_TOUCH_CANCEL, "touchCancel"], [TOP_TOUCH_END, "touchEnd"], [TOP_TOUCH_MOVE, "touchMove"], [TOP_TOUCH_START, "touchStart"], [TOP_TRANSITION_END, "transitionEnd"], [TOP_VOLUME_CHANGE, "volumeChange"], [TOP_WAITING, "waiting"], [TOP_WHEEL, "wheel"]].forEach(function(_ref) {
          var topLevelType = _ref[0], eventType = _ref[1];
          ReactTestUtils.SimulateNative[eventType] = makeNativeSimulator(eventType, topLevelType);
        });
        var testUtils = ReactTestUtils.default || ReactTestUtils;
        module.exports = testUtils;
      })();
    }
  }
});

// node_modules/react-dom/test-utils.js
var require_test_utils = __commonJS({
  "node_modules/react-dom/test-utils.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_test_utils_development();
    }
  }
});
export default require_test_utils();
/*! Bundled license information:

react-dom/cjs/react-dom-test-utils.development.js:
  (** @license React v16.14.0
   * react-dom-test-utils.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-dom_test-utils.js.map
