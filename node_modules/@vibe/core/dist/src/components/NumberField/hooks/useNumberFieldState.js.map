{"version":3,"file":"useNumberFieldState.js","sources":["../../../../../src/components/NumberField/hooks/useNumberFieldState.ts"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\nimport { type NumberFieldProps } from \"../NumberField.types\";\nimport { calculateSteppedValue } from \"../utils/calcValue\";\n\nexport type UseNumberFieldStateProps = Pick<\n  NumberFieldProps,\n  \"value\" | \"onChange\" | \"min\" | \"max\" | \"step\" | \"disabled\" | \"readOnly\" | \"allowOutOfBounds\" | \"onValidityChange\"\n>;\n\nconst useNumberFieldState = ({\n  value: controlledValue,\n  onChange,\n  min,\n  max,\n  step = 1,\n  disabled,\n  readOnly,\n  allowOutOfBounds,\n  onValidityChange\n}: UseNumberFieldStateProps) => {\n  const [inputValue, setInputValue] = useState(controlledValue === null ? \"\" : String(controlledValue));\n\n  useEffect(() => {\n    const controlledValueStr = controlledValue === null ? \"\" : String(controlledValue);\n    setInputValue(prevInputValue =>\n      controlledValue !== parseFloat(prevInputValue) ? controlledValueStr : prevInputValue\n    );\n  }, [controlledValue]);\n\n  const handleChange = useCallback(\n    (event: React.ChangeEvent<HTMLInputElement>) => {\n      const stringValue = event.target.value;\n\n      if (stringValue === \"\") {\n        setInputValue(\"\");\n        onChange(null, event);\n        return;\n      }\n\n      const numericRegex = /^-?\\d*\\.?\\d*$/;\n      if (!numericRegex.test(stringValue)) {\n        return;\n      }\n\n      setInputValue(stringValue);\n      const isPartial = stringValue === \"-\" || stringValue.endsWith(\".\");\n      if (isPartial && stringValue.length === 1 && stringValue.endsWith(\".\")) {\n        onChange(0, event);\n        return;\n      }\n\n      if (!isPartial) {\n        const newNumber = parseFloat(stringValue);\n        if (allowOutOfBounds) {\n          if (newNumber !== controlledValue) {\n            onChange(newNumber, event);\n          }\n          return;\n        }\n\n        const clampedValue = Math.max(min ?? -Infinity, Math.min(max ?? Infinity, newNumber));\n        if (clampedValue !== controlledValue) {\n          onChange(clampedValue, event);\n        }\n      }\n    },\n    [onChange, allowOutOfBounds, min, max, controlledValue]\n  );\n\n  useEffect(() => {\n    if (!onValidityChange) return;\n\n    if (controlledValue === null) {\n      onValidityChange(true);\n      return;\n    }\n\n    const isWithinBounds =\n      (min === undefined || controlledValue >= min) && (max === undefined || controlledValue <= max);\n    onValidityChange(isWithinBounds);\n  }, [controlledValue, min, max, onValidityChange]);\n\n  const handleKeyDown = useCallback(\n    (event: React.KeyboardEvent<HTMLInputElement>) => {\n      if (disabled || readOnly) {\n        return;\n      }\n\n      const isArrowUp = event.key === \"ArrowUp\";\n      const isArrowDown = event.key === \"ArrowDown\";\n\n      if (isArrowUp || isArrowDown) {\n        event.preventDefault();\n        const direction = isArrowUp ? 1 : -1;\n        const newValue = calculateSteppedValue({\n          value: controlledValue,\n          direction,\n          step,\n          min,\n          max,\n          allowOutOfBounds\n        });\n        onChange(newValue, event);\n      }\n    },\n    [controlledValue, step, min, max, onChange, disabled, readOnly, allowOutOfBounds]\n  );\n\n  const isAtMin = !allowOutOfBounds && controlledValue !== null && min !== undefined && controlledValue <= min;\n  const isAtMax = !allowOutOfBounds && controlledValue !== null && max !== undefined && controlledValue >= max;\n\n  return {\n    inputValue,\n    numericValue: controlledValue,\n    onChange: handleChange,\n    onKeyDown: handleKeyDown,\n    isAtMin,\n    isAtMax\n  };\n};\n\nexport default useNumberFieldState;\n"],"names":["useNumberFieldState","_ref","controlledValue","value","onChange","min","max","_ref$step","step","disabled","readOnly","allowOutOfBounds","onValidityChange","_useState","useState","String","_useState2","_slicedToArray","inputValue","setInputValue","useEffect","controlledValueStr","prevInputValue","parseFloat","handleChange","useCallback","event","stringValue","target","test","isPartial","endsWith","length","newNumber","clampedValue","Math","Infinity","undefined","handleKeyDown","isArrowUp","key","preventDefault","newValue","calculateSteppedValue","direction","numericValue","onKeyDown","isAtMin","isAtMax"],"mappings":"iNASA,IAAMA,EAAsB,SAAHC,GAUM,IATtBC,EAAeD,EAAtBE,MACAC,EAAQH,EAARG,SACAC,EAAGJ,EAAHI,IACAC,EAAGL,EAAHK,IAAGC,EAAAN,EACHO,KAAAA,OAAO,IAAHD,EAAG,EAACA,EACRE,EAAQR,EAARQ,SACAC,EAAQT,EAARS,SACAC,EAAgBV,EAAhBU,iBACAC,EAAgBX,EAAhBW,iBAEAC,EAAoCC,EAA6B,OAApBZ,EAA2B,GAAYA,EAAPa,IAAwBC,EAAAC,EAAAJ,EAAA,GAA9FK,EAAUF,EAAA,GAAEG,EAAaH,EAAA,GAEhCI,GAAU,WACR,IAAMC,EAAyC,OAApBnB,EAA2B,GAAYA,EAAPa,GAC3DI,GAAc,SAAAG,GAAc,OAC1BpB,IAAoBqB,WAAWD,GAAkBD,EAAqBC,IAE1E,GAAG,CAACpB,IAEJ,IAAMsB,EAAeC,GACnB,SAACC,GACC,IAAMC,EAAcD,EAAME,OAAOzB,MAEjC,GAAoB,KAAhBwB,EAGF,OAFAR,EAAc,SACdf,EAAS,KAAMsB,GAKjB,GADqB,gBACHG,KAAKF,GAAvB,CAIAR,EAAcQ,GACd,IAAMG,EAA4B,MAAhBH,GAAuBA,EAAYI,SAAS,KAC9D,GAAID,GAAoC,IAAvBH,EAAYK,QAAgBL,EAAYI,SAAS,KAChE3B,EAAS,EAAGsB,QAId,IAAKI,EAAW,CACd,IAAMG,EAAYV,WAAWI,GAC7B,GAAIhB,EAIF,YAHIsB,IAAc/B,GAChBE,EAAS6B,EAAWP,IAKxB,IAAMQ,EAAeC,KAAK7B,IAAID,QAAAA,GAAQ+B,IAAUD,KAAK9B,IAAIC,QAAAA,EAAO8B,IAAUH,IACtEC,IAAiBhC,GACnBE,EAAS8B,EAAcR,EAE1B,CAtBA,CAuBH,GACA,CAACtB,EAAUO,EAAkBN,EAAKC,EAAKJ,IAGzCkB,GAAU,WACHR,GASLA,EAPwB,OAApBV,UAMOmC,IAARhC,GAAwCA,EAAnBH,QAAoCmC,IAAR/B,GAAqBJ,EAAmBI,GAE7F,GAAE,CAACJ,EAAiBG,EAAKC,EAAKM,IAE/B,IAAM0B,EAAgBb,GACpB,SAACC,GACC,IAAIjB,IAAYC,EAAhB,CAIA,IAAM6B,EAA0B,YAAdb,EAAMc,IAGxB,GAAID,GAF8B,cAAdb,EAAMc,IAEI,CAC5Bd,EAAMe,iBACN,IACMC,EAAWC,EAAsB,CACrCxC,MAAOD,EACP0C,UAHgBL,EAAY,GAAK,EAIjC/B,KAAAA,EACAH,IAAAA,EACAC,IAAAA,EACAK,iBAAAA,IAEFP,EAASsC,EAAUhB,EACpB,CAjBA,CAkBH,GACA,CAACxB,EAAiBM,EAAMH,EAAKC,EAAKF,EAAUK,EAAUC,EAAUC,IAMlE,MAAO,CACLO,WAAAA,EACA2B,aAAc3C,EACdE,SAAUoB,EACVsB,UAAWR,EACXS,SARepC,GAAwC,OAApBT,QAAoCmC,IAARhC,GAAwCA,GAAnBH,EASpF8C,SARerC,GAAwC,OAApBT,QAAoCmC,IAAR/B,GAAqBJ,GAAmBI,EAU3G"}